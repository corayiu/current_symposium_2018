<!DOCTYPE html>
<html>
<head>
    <title>CURRENT - Feminist Electronic Art Symposium</title>
    <script src="//cdn.jsdelivr.net/npm/jquery.marquee@1.5.0/jquery.marquee.min.js" type="text/javascript"></script>
<link rel="stylesheet" type="text/css" href="menu.css">
    <link rel="stylesheet" type="text/css" href="stylin.css">
        <link href="https://fonts.googleapis.com/css?family=Antic+Didone" rel="stylesheet">
<link href="https://fonts.googleapis.com/css?family=Montserrat:300,400,500" rel="stylesheet">
    <meta charset="UTF-8"> 
<meta name="viewport" content="width=device-width, initial-scale=1">
<style>   /* ul {
        margin: 0;
        padding: 1em;
    }
    ul li {
        line-height: 2em;
        list-style: circle;
    }*/
    /* OPTIONAL THEMING *//*
    .mobile-toggleable-menu {
        background-color: transparent;
        color: #fff;
        display: block;
     
        height: 40px;
        padding: 0;
    }
    .mobmenu-toggle {
        background-color: white;
        color: #2F251B;
        font-size: 35px;
        text-decoration: none;
        text-align: center;
        font-weight: bold;
        height: 50px;
        line-height: 50px;
    }
    .mobile-toggleable-menu li {
        display: inline-block;
        padding: 0;
        margin: 0;
        height: 40px;
    }
    .mobile-toggleable-menu li a {
        display: block;
        text-decoration: none;
        color: #2F251B;
        padding: 0 10px;
    }
    .mobile-toggleable-menu li a:hover {
        color: #2F251B;
    }
    .mobmenu-toggle:hover {
        background-color: #fff;
    }
    @media handheld, screen and (max-width: 480px) {
        .mobile-menu-toggle-button:checked ~ .mobmenu-toggle {
            background-color: #2F251B;
            color: #BA2E17;
            -webkit-transform: rotate(-120deg);
            border-radius: 50%;
            top: 10px;
            left:10px;
        }
            ul li {
        line-height: 6em;
        list-style: none;
        font-size:3.3vw; }

           .mobile-toggleable-menu li a {
        display: block;
        text-decoration: none;
        color: #2F251B;
        padding: 0 5px;
                         }*/

                         
</style>

</head>
<body>

    <!--    <div role="main" id="scissoring" class="wrapper">
        <img src="scissors-01.png">

    </div> -->


        <script src="js/three.js"></script>
        <script src="js/Detector.js"></script>
        <script src="js/OrbitControls.js"></script>
        <script src="js/SimplexNoise.js"></script>
        <script src="js/GPUComputationRenderer.js"></script>
        


        <!-- This is the 'compute shader' for the water heightmap: -->
        <script id="heightmapFragmentShader" type="x-shader/x-fragment">

            #include <common>

            uniform vec2 mousePos;
            uniform float mouseSize;
            uniform float viscosityConstant;

            #define deltaTime ( 1.0 / 60.0 )
            #define GRAVITY_CONSTANT ( resolution.x * deltaTime * 3.0 )

            void main() {

                vec2 cellSize = 1.0 / resolution.xy;

                vec2 uv = gl_FragCoord.xy * cellSize;

                // heightmapValue.x == height
                // heightmapValue.y == velocity
                // heightmapValue.z, heightmapValue.w not used
                vec4 heightmapValue = texture2D( heightmap, uv );

                // Get neighbours
                vec4 north = texture2D( heightmap, uv + vec2( 0.0, cellSize.y ) );
                vec4 south = texture2D( heightmap, uv + vec2( 0.0, - cellSize.y ) );
                vec4 east = texture2D( heightmap, uv + vec2( cellSize.x, 0.0 ) );
                vec4 west = texture2D( heightmap, uv + vec2( - cellSize.x, 0.0 ) );

                float sump = north.x + south.x + east.x + west.x - 4.0 * heightmapValue.x;

                float accel = sump * GRAVITY_CONSTANT;

                // Dynamics
                heightmapValue.y += accel;
                heightmapValue.x += heightmapValue.y * deltaTime;

                // Viscosity
                heightmapValue.x += sump * viscosityConstant;

                // Mouse influence
                float mousePhase = clamp( length( ( uv - vec2( 0.5 ) ) * BOUNDS - vec2( mousePos.x, - mousePos.y ) ) * PI / mouseSize, 0.0, PI );
                heightmapValue.x += cos( mousePhase ) + 1.0;

                gl_FragColor = heightmapValue;

            }

        </script>

        <!-- This is just a smoothing 'compute shader' for using manually: -->
        <script id="smoothFragmentShader" type="x-shader/x-fragment">

            uniform sampler2D texture;

            void main() {

                vec2 cellSize = 1.0 / resolution.xy;

                vec2 uv = gl_FragCoord.xy * cellSize;

                // Computes the mean of texel and 4 neighbours
                vec4 textureValue = texture2D( texture, uv );
                textureValue += texture2D( texture, uv + vec2( 0.0, cellSize.y ) );
                textureValue += texture2D( texture, uv + vec2( 0.0, - cellSize.y ) );
                textureValue += texture2D( texture, uv + vec2( cellSize.x, 0.0 ) );
                textureValue += texture2D( texture, uv + vec2( - cellSize.x, 0.0 ) );

                textureValue /= 5.0;

                gl_FragColor = textureValue;

            }

        </script>

        <!-- This is the water visualization shader, copied from the MeshPhongMaterial and modified: -->
        <script id="waterVertexShader" type="x-shader/x-vertex">

            uniform sampler2D heightmap;

            #define PHONG

            varying vec3 vViewPosition;

            #ifndef FLAT_SHADED

                varying vec3 vNormal;

            #endif

            #include <common>
            #include <uv_pars_vertex>
            #include <uv2_pars_vertex>
            #include <displacementmap_pars_vertex>
            #include <envmap_pars_vertex>
            #include <color_pars_vertex>
            #include <morphtarget_pars_vertex>
            #include <skinning_pars_vertex>
            #include <shadowmap_pars_vertex>
            #include <logdepthbuf_pars_vertex>
            #include <clipping_planes_pars_vertex>

            void main() {

                vec2 cellSize = vec2( 1.0 / WIDTH, 1.0 / WIDTH );

                #include <uv_vertex>
                #include <uv2_vertex>
                #include <color_vertex>

                // # include <beginnormal_vertex>
                // Compute normal from heightmap
                vec3 objectNormal = vec3(
                    ( texture2D( heightmap, uv + vec2( - cellSize.x, 0 ) ).x - texture2D( heightmap, uv + vec2( cellSize.x, 0 ) ).x ) * WIDTH / BOUNDS,
                    ( texture2D( heightmap, uv + vec2( 0, - cellSize.y ) ).x - texture2D( heightmap, uv + vec2( 0, cellSize.y ) ).x ) * WIDTH / BOUNDS,
                    1.0 );
                //<beginnormal_vertex>

                #include <morphnormal_vertex>
                #include <skinbase_vertex>
                #include <skinnormal_vertex>
                #include <defaultnormal_vertex>

            #ifndef FLAT_SHADED // Normal computed with derivatives when FLAT_SHADED

                vNormal = normalize( transformedNormal );

            #endif

                //# include <begin_vertex>
                float heightValue = texture2D( heightmap, uv ).x;
                vec3 transformed = vec3( position.x, position.y, heightValue );
                //<begin_vertex>

                #include <morphtarget_vertex>
                #include <skinning_vertex>
                #include <displacementmap_vertex>
                #include <project_vertex>
                #include <logdepthbuf_vertex>
                #include <clipping_planes_vertex>

                vViewPosition = - mvPosition.xyz;

                #include <worldpos_vertex>
                #include <envmap_vertex>
                #include <shadowmap_vertex>

            }

        </script>

        <script>

            if ( ! Detector.webgl ) Detector.addGetWebGLMessage();

            var hash = document.location.hash.substr( 1 );
            if ( hash ) hash = parseInt( hash, 0 );

            // Texture width for simulation
            var WIDTH = hash || 128;
            var NUM_TEXELS = WIDTH * WIDTH;

            // Water size in system units
            var BOUNDS = 512;
            var BOUNDS_HALF = BOUNDS * 0.5;

            var container;
            var camera, scene, renderer, controls;
            var mouseMoved = false;
            var mouseCoords = new THREE.Vector2();
            var raycaster = new THREE.Raycaster();

            var waterMesh;
            var meshRay;
            var gpuCompute;
            var heightmapVariable;
            var waterUniforms;
            var smoothShader;

            var simplex = new SimplexNoise();

            var windowHalfX = window.innerWidth / 2;
            var windowHalfY = window.innerHeight / 2;

            function change(n) {
                location.hash = n;
                location.reload();
                return false;
            }
        

            init();
            animate();

            function init() {

                container = document.createElement( 'div' );
                document.body.appendChild( container );

                camera = new THREE.PerspectiveCamera( 75, window.innerWidth / window.innerHeight, 1, 3000 );
                camera.position.set( 0, 200, 350 );

                scene = new THREE.Scene();

                var sun = new THREE.DirectionalLight( 0xFFFFFF, 1.0 );
                sun.position.set( 300, 400, 175 );
                scene.add( sun );

                var sun2 = new THREE.DirectionalLight( 0x40A040, 0.8 );
                sun2.position.set( -100, 350, -200 );
                scene.add( sun2 );

                renderer = new THREE.WebGLRenderer();
                renderer.setPixelRatio( window.devicePixelRatio );
                renderer.setSize( window.innerWidth, window.innerHeight );
                container.appendChild( renderer.domElement );

                controls = new THREE.OrbitControls( camera, renderer.domElement ); {

                }

                document.addEventListener( 'mousemove', onDocumentMouseMove, false );
                document.addEventListener( 'touchstart', onDocumentTouchStart, false );
                document.addEventListener( 'touchmove', onDocumentTouchMove, false );

                document.addEventListener( 'keydown', function( event ) {

                    // W Pressed: Toggle wireframe
                    if ( event.keyCode === 67 ) {

                        waterMesh.material.wireframe = ! waterMesh.material.wireframe;
                        waterMesh.material.needsUpdate = true;

                    }

                } , false );

                window.addEventListener( 'resize', onWindowResize, false );


            

                var effectController = {
                    mouseSize: 40.0,
                    viscosity: 0.02
                };

                var valuesChanger = function() {

                    heightmapVariable.material.uniforms.mouseSize.value = effectController.mouseSize;
                    heightmapVariable.material.uniforms.viscosityConstant.value = effectController.viscosity;

                };



                


                initWater();

                valuesChanger();

            }


            function initWater() {

                var materialColor = 0x3718d8;

                var geometry = new THREE.PlaneBufferGeometry( BOUNDS, BOUNDS, WIDTH - 1, WIDTH -1 );

                // material: make a ShaderMaterial clone of MeshPhongMaterial, with customized vertex shader
                var material = new THREE.ShaderMaterial( {
                    uniforms: THREE.UniformsUtils.merge( [
                        THREE.ShaderLib[ 'phong' ].uniforms,
                        {
                            heightmap: { value: null }
                        }
                    ] ),
                    vertexShader: document.getElementById( 'waterVertexShader' ).textContent,
                    fragmentShader: THREE.ShaderChunk[ 'meshphong_frag' ]

                } );

                material.lights = true;

                // Material attributes from MeshPhongMaterial
                material.color = new THREE.Color( materialColor );
                material.specular = new THREE.Color( 0x111111 );
                material.shininess = 60;

                // Sets the uniforms with the material values
                material.uniforms.diffuse.value = material.color;
                material.uniforms.specular.value = material.specular;
                material.uniforms.shininess.value = Math.max( material.shininess, 1e-4 );
                material.uniforms.opacity.value = material.opacity;

                // Defines
                material.defines.WIDTH = WIDTH.toFixed( 1 );
                material.defines.BOUNDS = BOUNDS.toFixed( 1 );

                waterUniforms = material.uniforms;

                waterMesh = new THREE.Mesh( geometry, material );
                waterMesh.rotation.x = - Math.PI / 2;
                waterMesh.matrixAutoUpdate = false;
                waterMesh.updateMatrix();

                scene.add( waterMesh );

                // Mesh just for mouse raycasting
                var geometryRay = new THREE.PlaneBufferGeometry( BOUNDS, BOUNDS, 1, 1 );
                meshRay = new THREE.Mesh( geometryRay, new THREE.MeshBasicMaterial( { color: 0xFFFFFF, visible: false } ) );
                meshRay.rotation.x = - Math.PI / 2;
                meshRay.matrixAutoUpdate = false;
                meshRay.updateMatrix();
                scene.add( meshRay );


                // Creates the gpu computation class and sets it up

                gpuCompute = new GPUComputationRenderer( WIDTH, WIDTH, renderer );

                var heightmap0 = gpuCompute.createTexture();

                fillTexture( heightmap0 );

                heightmapVariable = gpuCompute.addVariable( "heightmap", document.getElementById( 'heightmapFragmentShader' ).textContent, heightmap0 );

                gpuCompute.setVariableDependencies( heightmapVariable, [ heightmapVariable ] );

                heightmapVariable.material.uniforms.mousePos = { value: new THREE.Vector2( 10000, 10000 ) };
                heightmapVariable.material.uniforms.mouseSize = { value: 20.0 };
                heightmapVariable.material.uniforms.viscosityConstant = { value: 0.02 };
                heightmapVariable.material.defines.BOUNDS = BOUNDS.toFixed( 1 );

                var error = gpuCompute.init();
                if ( error !== null ) {
                    console.error( error );
                }

                // Create compute shader to smooth the water surface and velocity
                smoothShader = gpuCompute.createShaderMaterial( document.getElementById( 'smoothFragmentShader' ).textContent, { texture: { value: null } } );

            }

            function fillTexture( texture ) {

                var waterMaxHeight = 15;

                function noise( x, y, z ) {
                    var multR = waterMaxHeight;
                    var mult = 0.025;
                    var r = 0;
                    for ( var i = 0; i < 15; i++ ) {
                        r += multR * simplex.noise( x * mult, y * mult );
                        multR *= 0.53 + 0.025 * i;
                        mult *= 1.25;
                    }
                    return r;
                }

                var pixels = texture.image.data;

                var p = 0;
                for ( var j = 0; j < WIDTH; j++ ) {
                    for ( var i = 0; i < WIDTH; i++ ) {

                        var x = i * 128 / WIDTH;
                        var y = j * 128 / WIDTH;

                            pixels[ p + 0 ] = noise( x, y, 123.4 );
                        pixels[ p + 1 ] = 0;
                        pixels[ p + 2 ] = 0;
                        pixels[ p + 3 ] = 1;

                        p += 4;
                    }
                }

            }

            function smoothWater() {

                var currentRenderTarget = gpuCompute.getCurrentRenderTarget( heightmapVariable );
                var alternateRenderTarget = gpuCompute.getAlternateRenderTarget( heightmapVariable );

                for ( var i = 0; i < 10; i++ ) {

                    smoothShader.uniforms.texture.value = currentRenderTarget.texture;
                    gpuCompute.doRenderTarget( smoothShader, alternateRenderTarget );

                    smoothShader.uniforms.texture.value = alternateRenderTarget.texture;
                    gpuCompute.doRenderTarget( smoothShader, currentRenderTarget );

                }
                
            }


            function onWindowResize() {

                windowHalfX = window.innerWidth / 1;
                windowHalfY = window.innerHeight / 1;

                camera.aspect = window.innerWidth / window.innerHeight;
                camera.updateProjectionMatrix();

                renderer.setSize( window.innerWidth, window.innerHeight );

            }

            function setMouseCoords( x, y ) {

                mouseCoords.set( ( x / renderer.domElement.clientWidth ) * 2 - 1, - ( y / renderer.domElement.clientHeight ) * 2 + 1 );
                mouseMoved = true;

            }

            function onDocumentMouseMove( event ) {

                setMouseCoords( event.clientX, event.clientY );

            }

            function onDocumentTouchStart( event ) {

                if ( event.touches.length === 1 ) {

                    event.preventDefault();

                    setMouseCoords( event.touches[ 0 ].pageX, event.touches[ 0 ].pageY );


                }

            }

            function onDocumentTouchMove( event ) {

                if ( event.touches.length === 1 ) {

                    event.preventDefault();

                    setMouseCoords( event.touches[ 0 ].pageX, event.touches[ 0 ].pageY );


                }

            }

            function animate() {

                requestAnimationFrame( animate );

                render();
        

            }

            function render() {

                // Set uniforms: mouse interaction
                var uniforms = heightmapVariable.material.uniforms;
                if ( mouseMoved ) {

                    this.raycaster.setFromCamera( mouseCoords, camera );

                    var intersects = this.raycaster.intersectObject( meshRay );

                    if ( intersects.length > 0 ) {
                        var point = intersects[ 0 ].point;
                        uniforms.mousePos.value.set( point.x, point.z );

                    }
                    else {
                        uniforms.mousePos.value.set( 10000, 10000 );
                    }

                    mouseMoved = false;
                }
                else {
                    uniforms.mousePos.value.set( 10000, 10000 );
                }

                // Do the gpu computation
                gpuCompute.compute();

                // Get compute output in custom uniform
                waterUniforms.heightmap.value = gpuCompute.getCurrentRenderTarget( heightmapVariable ).texture;

                // Render
                renderer.render( scene, camera );

            }

        </script>

<div class="grid">
    <div class="title"><a href="index.html"></a></div>
    <!-- <div class="nav"><nav><input type="checkbox" id="mobile-menu-toggle" class="mobile-menu-toggle mobile-menu-toggle-button">
        <ul id="plain-menu" class="mobile-toggleable-menu mobile-left">
            <li><a href="about.html" class="nav-undie">about</a></li>
            <li><a href="rates.html" class="nav-undie">rates</a></li>
            <li><a href="https://hairbymarleau.acuityscheduling.com/schedule.php" class="nav-undie" target="_blank">book</a></li>
            <li><a href="testis.html" class="nav-undie">testimonals</a></li>
            <li><a href="contact.html" class="nav-undie">contact</a></li></ul>
            <label class="mobile-right mobmenu-toggle" for="mobile-menu-toggle">:~)</label></nav>
            </div> -->
    <div class="content" style="letter-spacing: 2px;"><div class="verticaltext outline outlinem">DREAM</div><br><br><br><br><br><div class="verticaltext2">OF A <br>NEW <br>FUTURE</div></div>
    <div class="content3" style="letter-spacing: 2px;"></div>
    <div class="content2" style="letter-spacing: 2px;"><div class='marquee2' style="  color:#fff;background-color:#000;padding: 8px 0;"><span style="font-family:Wingdings">&#73;</span> CURRENT is a multidisciplinary, intersectional, music and electronic art symposium working with women and non-binary artists in Vancouver, BC and beyond</span></div><div class='marquee' style="  color:#fff;background-color:#000;padding: 7px 0;"><span>
    July 25 — 28, 2018 <span style="font-family:Wingdings">&#69;</span> MORE INFO COMING SOON <span style="font-family:Wingdings">&#74;</span> <a href="http://www.currentsymposium.com" style="color:blue;text-decoration: none;" target="_blank">VOLUNTEER NOW</a> <span style="font-family:Wingdings">&#42;</span> <a href="mailto:currentsymposium@gmail.com" style="color:blue;text-decoration: none;">CONTACT  US</a></span>
</div></div>

</div>  
  <script src='http://cdnjs.cloudflare.com/ajax/libs/jquery/2.1.3/jquery.min.js'></script>
<script src='http://cdn.jsdelivr.net/jquery.marquee/1.3.1/jquery.marquee.min.js'></script>
<script  src="js/marquee2.js"></script>

</body>


</html>

